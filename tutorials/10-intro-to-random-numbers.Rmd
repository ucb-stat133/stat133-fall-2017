---
title: "Random Numbers and Simulations"
subtitle: "Stat 133, Fall 2017"
author: "Gaston Sanchez"
output: github_document
fontsize: 11pt
urlcolor: blue
---

> ### Learning Objectives
>
> - How to use R to simulate chance processes
> - Getting to know the function `sample()`
> - Simulate flipping a coin
> - Simulate rolling a die
> - Simulate drawing tickets from a box

------

## Random Numebrs

Random numbers have many applications in science and computer programming,
especially when there are significant uncertainties in a phenomenon of interest.
The goal of this unit is to look at some practical problmes involving working
with random numbers and creating simulations.

The key idea in computer simulations with random numbers is first to formulate
an algorithmic description of the phenomenon we want to study. This description
frequently maps directly onto a simple R script, where we use random numbers to
mimic the uncertain features of the phenomenon. The script needs to perform a
large number of repeated calculations, and the final answers are only 
approximate, but the accuracy can usually be made good enough for practical
purposes.


# Generating Random Numbers

R has several functions that allows you to generate random numbers following
a certain distribution.

The function `sample()` takes a random sample from the input vector.

All computations of random numbers are based on deterministic algorithms, so 
the sequence of numbers is not truly random. However, the sequence of numbers
appears to lack any systematic pattern, and we can therefore regard the 
numbers as random.


## The Seed

Every time you use one of the random generator functions in R, the call 
produces different numbers. For replication and debugging purposes, it is 
useful to get the same sequence of random numebrs every time we run the script.
This functionality is obtained by setting a __seed__ before we start generating
the numebrs. The seed is an integer and set by the function `set.seed()`
```{r}
set.seed(123)
runif(4)
```

If we set the seed to `123` again, the sequence of uniform random numbers is
regenerated:
```{r}
set.seed(123)
runif(4)
```

If we don't specify a seed, the random generator functions set a seed based
on the current time. That is, the seed will be different each time we run the 
script and consequently the sequence of random numbers will also be different.


# Uniformly Distributed Random Numebrs

The numbers generated by `runif()` tend to be equally distributed between 0
and 1, which means that there is no part of the interval $[0, 1]$ with more
random numbers than other parts.
```{r}
set.seed(345)
n <- 500
x <- 1:n
y <- runif(n, min = -1, max = 1)

plot(x, y, las = 1, pch = 19, col = "#88888855")
```

The previous figure shows the values of 500 random uniformly distributed 
numbers between -1 and 1. Another interesting visualization involves looking
at how the random numbers are distributed in the given interval.

```{r}
hist(y, las = 1, col = "gray80")
```


## Drawing Integers

To simulate drawing random integers, you can use the function `sample.int()`.
The main argument is `n`, which represents the maximum integer to sample
from: `1, 2, 3, ..., n`
```{r}
sample.int(10)
```


# Computing Probabilities

With the mathematical rules from probability theory we can compute the 
probability that a certain event happens, say the probability that you get one
blue ball when drawing three balls from a box with four blue balls, five
white balls, and three yellow balls. Unfortunately, theoretical calculations 
of probabilities may soon become hard or impossible if the problem is slightly
changed. There is a simple numerical way of computing probabilities that is
generally applicable to problems with uncertainty: Monte Carlo Simulation.


## Principles of Monte Carlo Simulation

Assume that we perform $N$ experiments where the outcome of each experiment
is random. Suppose that some event takes place $M$ times in these $N$
experiments. An estimate of the probability of the event is then $M/N$. The
estimate becomes more accurate as $N$ increases, and the exact probability is
assumed to be reached in the limit as $N \rightarrow \infty$.

Programs that run a large number of experiments and record the outcome of 
events are often called simulation programs. The mathematical technique of
letting the computer perform lots of experiments based on drawing random
numbers is commonly called __Monte Carlo simulation__. Many probabilistic
problems can be calculated exactly by mathematics from probability theory, 
but very often Monte Carlo simulation is the only way to solve statistical
problems.


## Example: Drawing balls from a box

Suppose there are 11 balls in a box: four blue, five white, and three yellow.
We want to write R code that draws three balls at random without replacement
from the box, and compute the probability of drawing two or more blue balls.
```{r}
# colored balls in a box
box <- c(rep('blue', 4), rep('white', 5), rep('yellow', 3))
box

# drawing three balls without replacement
sample(box, 3)
```

In this example you can apply the probability rules to find the probability of
getting at least two blue balls from drawing three balls out of the box. But
let's see how to use Monte Carlo simulation to find an approximate value for
such probability. We are going to simulate 1000 repetitions of the experiment.
Each repetition involves drawing three balls. To store the outputs we can use
a matrix of 1000 rows and three columns:
```{r}
# number of balls drawn, and repetitions
draw <- 3
reps <- 1000

outputs <- matrix("", nrow = reps, ncol = draw)
set.seed(123)
for (i in 1:reps) {
  outputs[i,] <- sample(box, draw)
}
head(outputs)
```

Now that we have our 1000 repetitions, let's compute the number of blue balls
for each row in `outputs`:
```{r}
# number of blue balls in each experiment
blues <- apply(outputs, 1, function(x) sum(x == "blue"))

# number of at least two blue balls
sum(blues >= 2)

# approx probability of two or more blue balls
sum(blues >= 2) / reps
```
